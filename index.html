<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Adventure Game 2.0</title>
</head>

<body>
    <canvas id="canvi"></canvas>
    <script>
var canvas = document.getElementById("canvi");
var ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var mouseX = 0;
var mouseY = 0;
var dragged = false;
var clicked = false
var keys = [];
var showHitbox = true;
function keysPressed(e) {
  keys[e.keyCode] = true;
  e.preventDefault();
}
function keysReleased(e) {
  keys[e.keyCode] = false;
}
ctx.textAlign = "center";

canvas.addEventListener("mousemove", function(e) {
    var cRect = canvas.getBoundingClientRect();
    mouseX = Math.round(e.clientX - cRect.left);
    mouseY = Math.round(e.clientY - cRect.top);
});
canvas.addEventListener("mousedown", function(e) {
    dragged = true;
}, false);
canvas.addEventListener("mouseup", function(e) {
    if(dragged === true) {
        clicked = true;
        dragged = false;
    }
}, false);
window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);
var player;
var enemies;
var scene = "game";
var hitboxGroups;
var props = [];
var walls = [];
var frameCount = 0;
var render = [];
var cam = {
    x: 0,
    y: 0,
}
var enemyNum = {}
var weaponStats = {
    "Basic Sword": {
        kb: 3,
        dmg: 0.4,
    }
}

var upgrades = {
    // Jack of All
    "Enchance": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Enchance"]) {
            player.sp-=2;
            player.maxHealth*=1.2;
            player.health*=1.2;
            player.healthRegen*=1.2;
            player.maxMana*=1.2;
            player.mana*=1.2;
            player.manaRegen*=1.2;
            player.upgrades["Enchance"] = player.upgrades["Enchance"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: 0, y: -80, colorScheme: "jack", desc: "20% more max + regen health and mana"},
    
    // Health
    "Vitality": {func: function() {
        if(player.sp >= 1 && !player.upgrades["Vitality"]) {
            player.sp-=1;
            player.health*=1.2;
            player.maxHealth*=1.2;
            player.healthRegen*=1.2;
            player.upgrades["Vitality"] = player.upgrades["Vitality"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 1, x: 0, y: 40, colorScheme: "health", desc: "20% more max health and regen"},
    "Tank": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Tank"]) {
            player.sp-=2;
            player.armor*=0.95;
            player.upgrades["Tank"] = player.upgrades["Tank"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: -40, y: 90, colorScheme: "health", connect: "Vitality", desc: "5% damage reduction"},
    "Regen": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Regen"]) {
            player.sp-=2;
            player.healthRegen*=1.5;
            player.upgrades["Regen"] = player.upgrades["Regen"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: 40, y: 160, colorScheme: "health", connect: "Health Pool", desc: "50% more health regen"},
    "Tough Hide": {func: function() {
        if(player.sp >= 3 && !player.upgrades["Tough Hide"]) {
            player.sp-=3;
            player.armor*=0.9;
            player.upgrades["Tough Hide"] = player.upgrades["Tough Hide"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 3, x: -40, y: 160, colorScheme: "health", connect: "Tank", desc: "10% damage reduction"},
    "Strength": {func: function() {
        if(player.sp >= 1 && !player.upgrades["Strength"]) {
            player.sp-=1;
            player.strength*=1.1;
            player.upgrades["Strength"] = player.upgrades["Strength"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 1, x: -110, y: 160, colorScheme: "health", connect: "Tank", desc: "10% more melee damage"},
    "Health Pool": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Health Pool"]) {
            player.sp-=2;
            player.health*=1.4;
            player.maxHealth*=1.4;
            player.upgrades["Health Pool"] = player.upgrades["Health Pool"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: 40, y: 90, colorScheme: "health", connect: "Vitality", desc: "40% more max health"},
    
    //Mobility
    "Dash": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Dash"]) {
            player.sp-=2;
            player.upgrades["Dash"] = player.upgrades["Dash"] + 1 || 1;
        }
    }, maxLvl: 2, spCost: 2, x: -80, y: 0, colorScheme: "mobility", desc: "unlocks dashing: [Shift] to use"},
    
    // Mana
    "Mana": {func: function() {
        if(player.sp >= 1 && !player.upgrades["Mana"]) {
            player.sp-=1;
            player.mana*=1.2;
            player.maxMana*=1.2;
            player.manaRegen*=1.2;
            player.upgrades["Mana"] = player.upgrades["Mana"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 1, x: 80, y: 0, colorScheme: "mana", desc: "20% max mana and mana regen"},
    "Mana Regen": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Mana Regen"]) {
            player.sp-=2;
            player.manaRegen*=1.5;
            player.upgrades["Mana Regen"] = player.upgrades["Mana Regen"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: 130, y: -40, colorScheme: "mana", connect: "Mana", desc: "50% more mana regen"},
    "Mana Pool": {func: function() {
        if(player.sp >= 2 && !player.upgrades["Mana"]) {
            player.sp-=2;
            player.mana*=1.4;
            player.maxMana*=1.4;
            player.upgrades["Mana Pool"] = player.upgrades["Mana Pool"] + 1 || 1;
        }
    }, maxLvl: 5, spCost: 2, x: 130, y: 40, colorScheme: "mana", connect: "Mana", desc: "40% more max mana"},
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
}
function prop(x, y, type, options) {
    this.x = x;
    this.y = y;
    this.index = x;
    this.type = type;
    this.options = options;
}
prop.prototype.draw = function() {
    switch(this.type) {
        case "grass":
            ctx.lineWidth = 4;
            ctx.strokeStyle = "rgb(16, 143, 11)"
            ctx.beginPath(); 
            ctx.moveTo(this.x - 10, this.y - 8); 
            ctx.lineTo(this.x, this.y); 
            ctx.stroke();
            ctx.beginPath(); 
            ctx.moveTo(this.x + 10, this.y - 8); 
            ctx.lineTo(this.x, this.y); 
            ctx.stroke();
            ctx.beginPath(); 
            ctx.moveTo(this.x, this.y - 10); 
            ctx.lineTo(this.x, this.y + 1); 
            this.index = this.y;
            ctx.stroke();
        break;
        case "signpost":
            ctx.lineWidth = 7;
            ctx.strokeStyle = "rgb(138, 76, 5)"
            ctx.beginPath(); 
            ctx.moveTo(this.x, this.y - 45); 
            ctx.lineTo(this.x, this.y + 1); 
            ctx.stroke();
            ctx.fillStyle = "rgb(137, 76, 5)"
            ctx.fillRect(this.x - 25, this.y - 70, 50, 25)
            this.index = this.y;
            
            // arrow
            if(this.options.direction === "left") {
                ctx.beginPath();
                ctx.moveTo(this.x - 24.5, this.y - 70);
                ctx.lineTo(this.x - 45, this.y - 57.5);
                ctx.lineTo(this.x - 24.5, this.y - 45)
                ctx.fill();
            } else if(this.options.direction === "right") {
                ctx.beginPath();
                ctx.moveTo(this.x + 24.5, this.y - 70);
                ctx.lineTo(this.x + 45, this.y - 57.5);
                ctx.lineTo(this.x + 24.5, this.y - 45)
                ctx.fill();
            }
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.textAlign = "center"
            ctx.font = this.options.size + "px Arial";
            ctx.fillText(this.options.txt, this.x + this.options.xOffset, this.y - 57 + this.options.size * 0.37);
        break;
    }
}
prop.prototype.update = function() {
    switch(this.type) {
        case "grass":
            if(this.x < player.x - canvas.width/2 - 100) {
                this.x = player.x + canvas.width/2 + 100 * Math.random();
            } else if(this.x > player.x + canvas.width/2 + 100) {
                this.x = player.x - canvas.width/2 - 100 * Math.random();
            }
            if(this.y < player.y - canvas.height/2 - 100) {
                this.y = player.y + canvas.height/2 + 100 * Math.random();
            } else if(this.y > player.y + canvas.height/2 + 100) {
                this.y = player.y - canvas.height/2 - 100 * Math.random();
            }
        break;
    }
}
function Wall(x, y, w, h, type, opt) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.type = type;
    this.opt = opt;
    this.index = this.y + this.h;
};
Wall.prototype.draw = function() {
    switch(this.type) {
        case "wall":
            ctx.fillStyle = this.opt.color;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            hitboxGroup["Walls"].hitboxes[this.x + ", " + this.y + ", " + this.w + ", " + this.h] = {
                x: this.x, 
                y: this.y, 
                w: this.w,
                h: this.h,
                refer: this,
                type: "wall",
            }
        break;
    }
};

function hitboxGroup(hitboxes, func) {
    this.hitboxes = hitboxes;
    this.func = func;
};
hitboxGroup.prototype.check = function(p1, p2, padding) {
    if(!p1.s || !p2.s) {
        let p1w = p1.s || p1.w;
        let p1h = p1.s || p1.h;
        let p2w = p2.s || p2.w;
        let p2h = p2.s || p2.h;
        return p1.x > p2.x + p2w && p1.x + p1w < p2.x && p1.y > p2.y < p2h && p1.y + p1h < p2.y;
    } else {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)) <= (p1.s/2 + p2.s/2) * 2 + padding;
    }
};
hitboxGroup.prototype.draw = function() {
    for(let i in this.hitboxes) {
        let hitbox = this.hitboxes[i]
        ctx.fillStyle = "rgb(255, 0, 0, 0.3)"
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(hitbox.x, hitbox.y, hitbox.s, hitbox.s, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
}
function wrappedText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';

    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;

        if (testWidth > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }

    ctx.fillText(line, x, y);
}
function button(x, y, w, h, func, opt) {
    if(!opt.upgradeButton && mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h || opt.upgradeButton && dist(mouseX, mouseY, x - cam.x, y - cam.y) < w) {
        if(clicked) {
            func(opt.args);
        }
        ctx.fillStyle = opt.hoverColor;
    } else if(opt.upgrade) {
        if(player.upgrades[opt.upgrade]) {
            ctx.fillStyle = opt.upgradeCol;
        } else {
            ctx.fillStyle = opt.color;
        }
    } else {
        ctx.fillStyle = opt.color;
    }
    if(opt.upgradeButton) {
        ctx.beginPath();
        ctx.ellipse(x - canvas.width/2, y - canvas.height/2, w, h, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = opt.txtColor;
        ctx.textAlign = "center";
        ctx.font = opt.txtSize + "px Arial"
        ctx.fillText(opt.txt, x - canvas.width/2, y + opt.yOffset - canvas.height/2);
    } else if(!opt.upgradeButton) {
        ctx.fillRect(x - canvas.width/2, y - canvas.height/2, w, h);
        ctx.fillStyle = opt.txtColor;
    ctx.textAlign = "center";
    ctx.font = opt.txtSize + "px Arial"
    ctx.fillText(opt.txt, x + w/2 - canvas.width/2, y + h/2 + opt.yOffset - canvas.height/2);
    }
}
hitboxGroup.prototype.checkCollision = function(hitboxGroup, options) {
    hitboxes = hitboxGroup.hitboxes;
    var padding = options.padding || 0;
    for(let i in hitboxes) {
        for(let j in this.hitboxes) {
            if(this.check(hitboxes[i], this.hitboxes[j], padding)) {
                this.func(this.hitboxes[j], hitboxes[i])
            }
        }
    }
}

function Player() {
    this.x = 0;
    this.y = 0;
    this.index = 0;
    this.equippedIndex = 0;
    this.aX = 0;
    this.aY = 0;
    this.armor = 1;
    this.swings = [0, 0, 0, 0, 0];
    this.swing = 0;
    this.lvl = 1;
    this.strength = 1;
    this.stamina = 5;
    this.maxStamina = 5;
    this.staminaRegen = 0.005;
    this.exp = 0;
    this.size = 20;
    this.health = 10;
    this.maxHealth = 10;
    this.regen = 0.01;
    this.manaRegen = 0.005;
    this.spd = 2;
    this.mana = 5;
    this.maxMana = 5;
    this.exp = 0;
    //this.exp = 0;
    this.nxtLvlExp = 10;
    this.sp = 0;
    this.r = 0;
    this.equipped = "Basic Sword"
    this.upgrades = {};
    this.dashCD = 0;
}
Player.prototype.draw = function() {
    // health bar
    ctx.fillStyle = "rgb(0, 0, 0)"
    ctx.fillRect(this.x - this.size, this.y + this.size * 1.3, this.size * 2, this.size * 0.35);
    ctx.fillStyle = "rgb(40, 219, 13)"
    ctx.fillRect(this.x - this.size * 0.95, this.y + this.size * 1.35, this.size * 1.9 * this.health/this.maxHealth, this.size * 0.25);
    
    // player body
    ctx.fillStyle = "rgb(252, 219, 154)";
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.size, this.size, 0, 0, 2 * Math.PI);
    ctx.fill();
}
Player.prototype.update = function() {
    if(this.health <= 0) {
        this.x = 0;
        this.y = 0;
        this.health = this.maxHealth;
        this.mana = this.maxMana;
        this.index = 0;
        this.equippedIndex = 0;
        this.aX = 0;
        this.aY = 0;
        this.swings = [0, 0, 0, 0, 0];
        this.swing = 0;
        this.r = 0;
        for(let i = 0; i < props.length; i++) {
            if(props[i].type === "grass") {
                props.splice(i, 1);
                continue;
            }
        }
        for(let i = 0; i < Math.round(canvas.width * canvas.height)/8000; i++) {
            props.push(new prop(-100 - canvas.width/2 + (canvas.width + 200) * Math.random(), -100 - canvas.height/2 + (canvas.width + 200) * Math.random(), "grass"));
        }
    }
    this.swings = this.swings.slice(0, 4)
    var pr = this.r
    this.r = Math.atan2(canvas.height/2 - mouseY, canvas.width/2 - mouseX)
    this.swings.push(Math.min(Math.abs(pr - this.r), Math.abs(pr + 360 - this.r)));
    this.swing = 0;
    for(let i = 0; i < this.swings.length; i++) {
        this.swing+=this.swings[i]
    }
    this.swing/=this.swings.length;
    if(keys[87] || keys[38]) {
        this.aY-=this.spd;
    } else if(keys[83] || keys[40]) {
        this.aY+=this.spd;
    }
    if(keys[65] || keys[37]) {
        this.aX-=this.spd;
    } else if(keys[68] || keys[39]) {
        this.aX+=this.spd;
    }
    if(keys[16] && this.upgrades["Dash"] && this.dashCD <= 0) {
        this.dashCD = 100;
    }
    this.stamina = Math.max(Math.min(this.stamina, this.maxStamina), 0);
    if(this.dashCD >= 80 && this.stamina > 0) {
        this.stamina-=0.1;
        this.x-=Math.cos(this.r) * 3 * this.spd
        this.y-=Math.sin(this.r) * 3 * this.spd
        this.aX-=Math.cos(this.r) * 2 * this.spd;
        this.aY-=Math.sin(this.r) * 2 * this.spd
    }
    if(this.dashCD > 0) {
        this.dashCD-=1;
    }
    this.x+=this.aX;
    this.y+=this.aY;
    this.index = this.y + this.size;
    this.aX*=0.4;
    this.aY*=0.4
    if(this.health < this.maxHealth) {
        this.health+=this.regen;
    }
    if(this.mana < this.maxMana) {
        this.mana+=this.manaRegen;
    }
    if(this.stamina < this.maxStamina) {
        this.stamina+=this.staminaRegen;
    }
    if(this.exp >= this.nxtLvlExp) {
        this.lvl+=1;
        this.exp-=this.nxtLvlExp;
        this.nxtLvlExp+=3 + this.nxtLvlExp * 0.2;
        this.health+=this.maxHealth * 0.1;
        this.mana+=this.maxMana * 0.1;
        this.maxHealth*=1.1;
        this.maxMana*=1.1;
        this.regen*=1.1;
        this.manaRegen*=1.1;
        this.sp+=1 + Math.ceil(this.lvl/5)
    }
    this.health = Math.min(this.health, this.maxHealth)
    this.mana = Math.min(this.mana, this.maxMana);
    hitboxGroups["Player"].hitboxes = {
        "body": {
            x: this.x,
            y: this.y,
            s: this.size,
            refer: this,
            type: "player",
        },
    }
    switch(this.equipped) {
        case "Basic Sword":
            hitboxGroups["Sword"].hitboxes["p1"] = {
                x: this.x - Math.cos(this.r) * this.size * 6/3, 
                y: this.y  - Math.sin(this.r) * this.size * 6/3, 
                s: this.size/3,
                refer: this,
                type: "ally",
            };
            hitboxGroups["Sword"].hitboxes["p2"] = {
                x: this.x - Math.cos(this.r) * this.size * 8/3, 
                y: this.y  - Math.sin(this.r) * this.size * 8/3, 
                s: this.size/2,
                refer: this,
                type: "ally",
            };
            hitboxGroups["Sword"].hitboxes["p3"] = {
                x: this.x - Math.cos(this.r) * this.size * 22/6, 
                y: this.y  - Math.sin(this.r) * this.size * 22/6, 
                s: this.size/2,
                refer: this,
                type: "ally",
            };
            hitboxGroups["Sword"].hitboxes["p4"] = {
                x: this.x - Math.cos(this.r) * this.size * 28/6, 
                y: this.y  - Math.sin(this.r) * this.size * 28/6, 
                s: this.size/2,
                refer: this,
                type: "ally",
            };
            hitboxGroups["Sword"].hitboxes["p5"] = {
                x: this.x - Math.cos(this.r) * this.size * 34/6, 
                y: this.y  - Math.sin(this.r) * this.size * 34/6, 
                s: this.size/2,
                refer: this,
                type: "ally",
            };
            this.equippedIndex = Math.max(this.y - Math.sin(this.r) * (1.5 * this.size) + 15, this.y - Math.sin(this.r) * (6 * this.size) + 15)
            render.push({item: this, index: this.equippedIndex})
        break;
    }
}
Player.prototype.drawEquipped = function() {
    switch(this.equipped) {
        case "Basic Sword":
            ctx.fillStyle = "rgb(252, 219, 154)";
            ctx.beginPath();
            ctx.ellipse(this.x - Math.cos(this.r) * 40, this.y  - Math.sin(this.r) * 40, this.size/3, this.size/3, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.lineWidth = this.size/3;
            ctx.strokeStyle = "rgb(171, 86, 0)"
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (this.size * 1.5), this.y - Math.sin(this.r) * (this.size * 1.5)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (this.size * 2.5), this.y - Math.sin(this.r) * (this.size * 2.5)); 
            ctx.stroke();
            ctx.lineWidth = this.size * 0.75;
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (this.size * 2.5), this.y - Math.sin(this.r) * (this.size * 2.5)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (this.size * 2.8), this.y - Math.sin(this.r) * (this.size * 2.8)); 
            ctx.stroke(); 
            ctx.strokeStyle = "rgb(209, 209, 209)"
            ctx.lineWidth = this.size * 0.6;
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (6.02 * this.size), this.y - Math.sin(this.r) * (6.02 * this.size)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (2.8 * this.size), this.y - Math.sin(this.r) * (2.8 * this.size)); 
            ctx.stroke();
            
            // tip
            ctx.fillStyle = "rgb(209, 209, 209)"
            ctx.beginPath();
            ctx.moveTo(this.x - Math.cos(this.r) * 6 * this.size - Math.cos(this.r + Math.PI/2) * this.size * 0.3, this.y - Math.sin(this.r) * 6 * this.size - Math.sin(this.r + Math.PI/2) * this.size * 0.3);
            ctx.lineTo(this.x - Math.cos(this.r) * this.size * 6.6, this.y - Math.sin(this.r) * this.size * 6.6);
            ctx.lineTo(this.x - Math.cos(this.r) * 6 * this.size + Math.cos(this.r + Math.PI/2) * this.size * 0.3, this.y - Math.sin(this.r) * 6 * this.size + Math.sin(this.r + Math.PI/2) * this.size * 0.3);
            ctx.fill();
        break
    }
}

function Enemy(x, y, type, id) {
    this.x = x;
    this.y = y;
    this.target = null;
    this.aX = 0;
    this.aY = 0;
    this.type = type;
    this.size = 20;
    this.r = 0;
    this.id = id;
    this.health = 100;
    this.maxHealth = 100;
    this.index = 0;
    this.options = {};
    if(!enemyNum[this.type]) {
        enemyNum[this.type] = 0;
    }
    switch(this.type) {
        case "Goblin":
            this.size = 17;
            this.armor = 1;
            this.knockBackRes = 40;
            this.equipped = "Basic Sword"
            this.health = 18;
            this.maxHealth = 18;
            this.giveExp = 1.5;
            this.spd = 1;
            this.strength = 0.5;
            this.strafing = false;
            if(Math.random() < 0.5) {
                this.strafeFactor = -1;
            } else {
                this.strafeFactor = 1;
            }
            this.strafe = -50 + 100 * Math.random();
            this.movementType = "slash"
            this.swings = [0, 0, 0, 0, 0];
            this.swing = 0;
        break;
        case "Slime":
            this.health = 14;
            this.maxHealth = 14;
            this.armor = 1;
            this.knockBackRes = 20;
            this.giveExp = 1;
            this.spd = 3;
            this.size = 13;
            this.dmg = 2;
            this.bounceRate = Math.round(100 * Math.random());
            this.hitCD = 0;
            this.resetHitCD = 20;
            this.movementType = "bounce"
            this.options = {"dmgOnCollide": true}
        break;
    }
}
Enemy.prototype.draw = function() {
    switch(this.type) {
        case "Goblin":
            // health bar
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(this.x - this.size, this.y + this.size * 1.3, this.size * 2, this.size * 0.35);
            ctx.fillStyle = "rgb(219, 0, 0)"
            ctx.fillRect(this.x - this.size * 0.95, this.y + this.size * 1.35, this.size * 1.9 * this.health/this.maxHealth, this.size * 0.25);
            
            // body
            ctx.fillStyle = "rgb(245, 5, 5)";
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size, this.size, 0, 0, 2 * Math.PI);
            ctx.fill();
            this.index = this.y + this.size;
        break;
        case "Slime":
            ctx.fillStyle = "rgb(245, 5, 5)";
            ctx.beginPath();
            ctx.ellipse(this.x, this.y + this.size * 0.7, this.size, this.size * 1.5, 0, Math.PI, 0);
            ctx.fill();
            
            // health bar
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(this.x - this.size, this.y + this.size * 1.3, this.size * 2, this.size * 0.35);
            ctx.fillStyle = "rgb(219, 0, 0)"
            ctx.fillRect(this.x - this.size * 0.95, this.y + this.size * 1.35, this.size * 1.9 * this.health/this.maxHealth, this.size * 0.25);
            this.index = this.y + this.size;
        break;
    }
}
Enemy.prototype.findTarget = function() {
    if(dist(player.x, player.y, this.x, this.y) < 1000) {
        return player;
    }
    if(this.target) {
        if(dist(this.target.x, this.target.y, this.x, this.y) > 1500) {
            return null;
        }
    }
}
Enemy.prototype.update = function() {
    this.x+=this.aX;
    this.y+=this.aY;
    this.aX*=1 - this.knockBackRes/100;
    this.aY*=1 - this.knockBackRes/100;
    this.target = this.findTarget();
    switch(this.movementType) {
        case "slash":
            if(this.target) {
                if(this.strafing) {
                    this.strafe+=1 + Math.random() * 2 * (51 - this.strafe)/20;
                    if(this.strafe > 50 && dist(this.x, this.y, this.target.x, this.target.y) < (75 + this.size * 2 + this.target.size * 2)) {
                        this.strafing = false;
                    }
                } else {
                    this.strafe-=1 + Math.random() * 2 * (51 + this.strafe)/20;
                    if(this.strafe < -50 && dist(this.x, this.y, this.target.x, this.target.y) < (75 + this.size * 2 + this.target.size * 2)) {
                        this.strafing = true;
                    }
                }
                if(this.strafe <= 0) {
                    this.r = Math.atan2(this.y - this.target.y, this.x - this.target.x) + Math.min(-Math.PI/2 + Math.PI/2 * (1 - Math.abs(this.strafe)/50), Math.PI/2)
                } else {
                    this.r = Math.atan2(this.y - this.target.y, this.x - this.target.x) + Math.min(Math.PI/2 * Math.abs(this.strafe)/50, Math.PI/2)
                }
                var distance = dist(this.target.x, this.target.y, this.x, this.y);
                if(distance > this.target.size * 2 + 20 + Math.abs(this.strafe)) {
                    if(this.x < this.target.x) {
                        this.aX+=this.spd
                    }
                    if(this.x > this.target.x) {
                        this.aX-=this.spd
                    }
                    if(this.y < this.target.y) {
                        this.aY+=this.spd
                    }
                    if(this.y > this.target.y) {
                        this.aY-=this.spd
                    }
                } else if(distance < this.target.size * 2 + 15 + Math.abs(this.strafe)) {
                    if(this.x < this.target.x) {
                        this.aX-=this.spd
                    }
                    if(this.x > this.target.x) {
                        this.aX+=this.spd
                    }
                    if(this.y < this.target.y) {
                        this.aY-=this.spd
                    }
                    if(this.y > this.target.y) {
                        this.aY+=this.spd
                    }
                }
            }
        break;
        case "bounce":
            if(this.hitCD > 0) {
                this.hitCD-=1;
            }
            if(this.target) {
                r = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                if(this.bounceRate >= 100) {
                    if(dist(this.target.x, this.target.y, this.x, this.y) >= (this.size + this.target.size) * 2 + 100) {
                        this.aX = Math.cos(r) * this.spd * 4;
                        this.aY = Math.sin(r) * this.spd * 4;
                    } else {
                        this.aX = Math.cos(r + (-Math.PI/4, Math.PI/4)) * this.spd * 4;
                        this.aY = Math.sin(r + Math.PI/4, Math.PI/4) * this.spd * 4;
                    }
                    this.bounceRate = 0;
                } else {
                    this.bounceRate+=1;
                }
            }
        break;
    }
    switch(this.type) {
        case "Goblin":
            hitboxGroups["Sword"].hitboxes[this.id + "1"] = {
                x: this.x - Math.cos(this.r) * this.size * 6/3, 
                y: this.y  - Math.sin(this.r) * this.size * 6/3, 
                s: this.size/3,
                refer: this,
                type: "enemy",
            };
            hitboxGroups["Sword"].hitboxes[this.id + "2"] = {
                x: this.x - Math.cos(this.r) * this.size * 8/3, 
                y: this.y  - Math.sin(this.r) * this.size * 8/3, 
                s: this.size/2,
                refer: this,
                type: "enemy",
            };
            hitboxGroups["Sword"].hitboxes[this.id + "3"] = {
                x: this.x - Math.cos(this.r) * this.size * 22/6, 
                y: this.y  - Math.sin(this.r) * this.size * 22/6, 
                s: this.size/2,
                refer: this,
                type: "enemy",
            };
            hitboxGroups["Sword"].hitboxes[this.id + "4"] = {
                x: this.x - Math.cos(this.r) * this.size * 28/6, 
                y: this.y  - Math.sin(this.r) * this.size * 28/6, 
                s: this.size/2,
                refer: this,
                type: "enemy",
            };
            this.equippedIndex = Math.max(this.y - Math.sin(this.r) * (1.5 * this.size) + 15, this.y - Math.sin(this.r) * (6 * this.size) + 15)
            render.push({item: this, index: this.equippedIndex})
        break;
    }
    enemyNum[this.type]+=1;
    hitboxGroups["Enemies"].hitboxes[this.id] = {
        x: this.x,
        y: this.y,
        s: this.size,
        type: "enemy",
        refer: this,
        options: this.options
    }
}
Enemy.prototype.drawEquipped = function() {
    switch(this.equipped) {
        case "Basic Sword":
            ctx.fillStyle = "rgb(219, 0, 0)"
            // hand
            ctx.beginPath();
            ctx.ellipse(this.x - Math.cos(this.r) * 30, this.y  - Math.sin(this.r) * 30, this.size/3, this.size/3, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // sword
            ctx.lineWidth = 7;
            ctx.strokeStyle = "rgb(171, 86, 0)"
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (this.size * 1.3), this.y - Math.sin(this.r) * (this.size * 1.3)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (this.size * 2.5), this.y - Math.sin(this.r) * (this.size * 2.5)); 
            ctx.stroke();
            ctx.lineWidth = 20;
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (this.size * 2.5), this.y - Math.sin(this.r) * (this.size * 2.5)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (this.size * 2.8), this.y - Math.sin(this.r) * (this.size * 2.8)); 
            ctx.stroke(); 
            ctx.strokeStyle = "rgb(209, 209, 209)"
            ctx.lineWidth = 12;
            ctx.beginPath(); 
            ctx.moveTo(this.x - Math.cos(this.r) * (5.02 * this.size), this.y - Math.sin(this.r) * (5.02 * this.size)); 
            ctx.lineTo(this.x - Math.cos(this.r) * (2.8 * this.size), this.y - Math.sin(this.r) * (2.8 * this.size)); 
            ctx.stroke();
            
            
            // tip
            ctx.fillStyle = "rgb(209, 209, 209)"
            ctx.beginPath();
            ctx.moveTo(this.x - Math.cos(this.r) * 5 * this.size - Math.cos(this.r + Math.PI/2) * this.size * 0.3, this.y - Math.sin(this.r) * 5 * this.size - Math.sin(this.r + Math.PI/2) * this.size * 0.3);
            ctx.lineTo(this.x - Math.cos(this.r) * this.size * 5.6, this.y - Math.sin(this.r) * this.size * 5.6);
            ctx.lineTo(this.x - Math.cos(this.r) * 5 * this.size + Math.cos(this.r + Math.PI/2) * this.size * 0.3, this.y - Math.sin(this.r) * 5 * this.size + Math.sin(this.r + Math.PI/2) * this.size * 0.3);
            ctx.fill();
        break;
    }
}
Enemy.prototype.die = function() {
    if(this.health <= 0) {
        player.exp+=this.giveExp;
        delete hitboxGroups["Enemies"].hitboxes[this.id]
        delete hitboxGroups["Sword"].hitboxes[this.id + "1"]
        delete hitboxGroups["Sword"].hitboxes[this.id + "2"]
        delete hitboxGroups["Sword"].hitboxes[this.id + "3"]
        delete hitboxGroups["Sword"].hitboxes[this.id + "4"]
        return true;
    }
    return false;
}
function spawnEnemy() {
    for(let i = 0; i < 10 - enemyNum["Goblin"]; i++) {
        enemies.push(new Enemy(-1500 + 500 * Math.random(), -400 + 800 * Math.random(), "Goblin", "G" + i + "frame" + frameCount))
    }
    for(let i = 0; i < 10 - enemyNum["Slime"]; i++) {
        enemies.push(new Enemy(1500 - 500 * Math.random(), -400 + 800 * Math.random(), "Slime", "S" + i + "frame" + frameCount))
    }
}

player = new Player();
enemies = [];
hitboxGroups = {
    "Walls": new hitboxGroup({}, function(h1, h2) {
        h2.refer.aX-=1;
    }),
    "Enemies": new hitboxGroup({}, function(h1, h2) {
        if(h2.type === h1.type) {
            if(h1 !== h2) {
                let r = Math.atan2(h1.y - h2.y, h1.x - h2.x);
                let distance = dist(h1.x, h1.y, h2.x, h2.y);
                h2.refer.aX-=Math.cos(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h2.refer.aY-=Math.sin(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h1.refer.aX+=Math.cos(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h1.refer.aY+=Math.sin(r) * (h1.s + h2.s + 15 - distance) * 0.1;
            }
        } else {
            if(h1 !== h2) {
                let r = Math.atan2(h1.y - h2.y, h1.x - h2.x);
                let distance = dist(h1.x, h1.y, h2.x, h2.y);
                h2.refer.aX-=Math.cos(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h2.refer.aY-=Math.sin(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h1.refer.aX+=Math.cos(r) * (h1.s + h2.s + 15 - distance) * 0.1;
                h1.refer.aY+=Math.sin(r) * (h1.s + h2.s + 15 - distance) * 0.1;
            }
            if(h1.options.dmgOnCollide && h1.refer.hitCD <= 0) {
                h2.refer.health-=h1.refer.dmg * h2.refer.armor;
                h1.refer.hitCD = h1.refer.resetHitCD;
            }
        }
    }),
    "Player": new hitboxGroup({}, function(h1, h2) {
        
    }),
    "Sword": new hitboxGroup({}, function(h1, h2) {
        if(h2.type !== h1.type) {
            let r = Math.atan2(h1.y - h2.y, h1.x - h2.x)
            h2.refer.aX-=Math.cos(r) * weaponStats[h1.refer.equipped].kb * (1 + h1.refer.swing * 10);
            h2.refer.aY-=Math.sin(r) * weaponStats[h1.refer.equipped].kb * (1 + h1.refer.swing * 10);
            h2.refer.health-=(weaponStats[h1.refer.equipped].dmg + h1.refer.swing * 10) * h1.refer.strength * h2.refer.armor;
        }
    })
}
for(let i = 0; i < 10; i++) {
    enemies.push(new Enemy(-1500 + 500 * Math.random(), -400 + 800 * Math.random(), "Goblin", "G" + i))
    enemies.push(new Enemy(1500 - 500 * Math.random(), -400 + 800 * Math.random(), "Slime", "S" + i))
}
walls.push(new Wall(100, 100, 100, 100, "wall", {color: "rgb(158, 105, 44)"}));
for(let i = 0; i < Math.round(canvas.width * canvas.height)/8000; i++) {
    props.push(new prop(-100 - canvas.width/2 + (canvas.width + 200) * Math.random(), -100 - canvas.height/2 + (canvas.width + 200) * Math.random(), "grass"));
}
props.push(new prop(-150, 15, "signpost", {size: 13, txt: "Goblins", xOffset: -2, direction: "left"}));
props.push(new prop(150, 15, "signpost", {size: 13, txt: "Slimes", xOffset: 2, direction: "right"}));
ctx.translate(canvas.width/2, canvas.height/2)
var update = setInterval(function() {
    switch(scene) {
        case "game":
            for(let i in enemyNum) {
                enemyNum[i] = 0;
            }
            render = [];
            ctx.translate(player.x, player.y)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(68, 163, 84)";
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width * 2, canvas.height * 2)
            player.update();
            ctx.translate(-player.x, -player.y)
            for(var i = 0; i < props.length; i++) {
                props[i].update();
            }
            for(var i = 0; i < enemies.length; i++) {
                if(enemies[i] !== undefined) {
                    if(enemies[i].die()) {
                        enemies.splice(i, 1)
                        continue;
                    }
                    enemies[i].update();
                }
            }
            if(showHitbox) {
                hitboxGroups["Enemies"].draw();
                hitboxGroups["Sword"].draw();
                hitboxGroups["Player"].draw();
            }
            
            hitboxGroups["Sword"].checkCollision(hitboxGroups["Enemies"], {})
            hitboxGroups["Sword"].checkCollision(hitboxGroups["Player"], {})
            hitboxGroups["Enemies"].checkCollision(hitboxGroups["Enemies"], {padding: 15})
            hitboxGroups["Enemies"].checkCollision(hitboxGroups["Player"], {padding: 15})
            hitboxGroups["Walls"].checkCollision(hitboxGroups["Enemies"], {})
            hitboxGroups["Walls"].checkCollision(hitboxGroups["Player"], {})
            render = render.concat(enemies).concat(props).concat(walls);
            render.push(player);
            render.sort(function(a, b) {
                return a.index - b.index;
            })
            for(let i = 0; i < render.length; i++) {
                if(render[i].item) {
                    render[i].item.drawEquipped();
                } else {
                    render[i].draw();
                }
            }
            ctx.translate(player.x, player.y)
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(-canvas.width/2 + 10, canvas.height/2 - 112.5, 155, 25);
            ctx.fillStyle = "rgb(0, 219, 0)";
            ctx.fillRect(-canvas.width/2 + 12.5, canvas.height/2 - 110, 150 * player.health/player.maxHealth, 20)
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(-canvas.width/2 + 10, canvas.height/2 - 85, 155, 25);
            ctx.fillStyle = "rgb(0, 0, 219)";
            ctx.fillRect(-canvas.width/2 + 12.5, canvas.height/2 - 82.5, 150 * player.mana/player.maxMana, 20)
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(-canvas.width/2 + 10, canvas.height/2 - 57.5, 155, 25);
            ctx.fillStyle = "rgb(219, 219, 0)";
            ctx.fillRect(-canvas.width/2 + 12.5, canvas.height/2 - 55, 150 * player.exp/player.nxtLvlExp, 20)
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(-canvas.width/2 + 10, canvas.height/2 - 30, 155, 25);
            ctx.fillStyle = "rgb(217, 141, 0)";
            ctx.fillRect(-canvas.width/2 + 12.5, canvas.height/2 - 27.5, 150 * player.stamina/player.maxStamina, 20)
            ctx.fillStyle = "rgb(255, 255, 255)"
            ctx.font = "17px Arial";
            ctx.textAlign = "center"
            ctx.fillText(Math.round(player.stamina * 2)/2 + "/" + Math.round(player.maxStamina * 2)/2, -canvas.width/2 + 85, canvas.height/2 - 11.5);
            ctx.fillText(Math.round(player.health * 2)/2 + "/" + Math.round(player.maxHealth * 2)/2, -canvas.width/2 + 85, canvas.height/2 - 94.5);
            ctx.fillText(Math.round(player.mana * 2)/2 + "/" + Math.round(player.maxMana * 2)/2, -canvas.width/2 + 85, canvas.height/2 - 66.5);
            ctx.fillText(Math.round(player.exp * 2)/2 + "/" + Math.round(player.nxtLvlExp * 2)/2, -canvas.width/2 + 85, canvas.height/2 - 38.5);
            ctx.textAlign = "left"
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillText("Level: " + player.lvl, -canvas.width/2 + 15, canvas.height/2 - 118.5);
            ctx.textAlign = "right";
            ctx.fillText("SP: " + player.sp, -canvas.width/2 + 160, canvas.height/2 - 118.5);
            //x, y, w, h, func, opt: {hoverColor, color, txtColor, txtSize, txt, args, yOffset}
            button(10, canvas.height - 160.5, 70, 25, function() {
                scene = "upgrade"
                ctx.translate(player.x, player.y)
                ctx.translate(-cam.x, -cam.y)
            }, {hoverColor: "rgb(100, 100, 100)", color: "rgb(150, 150, 150)", txtColor: "rgb(0, 0, 0)", txtSize: 15, txt: "Upgrade", args: undefined, yOffset: 5})
            ctx.translate(-player.x, -player.y)
        break;
        case "upgrade":
            ctx.translate(cam.x, cam.y)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(33, 33, 33)";
            ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width * 2, canvas.height * 2)
            if(keys[87] || keys[38]) {
                cam.y-=5;
            } else if(keys[83] || keys[40]) {
                cam.y+=5;
            }
            if(keys[65] || keys[37]) {
                cam.x-=5;
            } else if(keys[68] || keys[39]) {
                cam.x+=5;
            }
            ctx.translate(-cam.x, -cam.y)
            
            
            ctx.fillStyle = "rgb(201, 201, 201)"
            // hand
            ctx.beginPath();
            ctx.ellipse(0, 0, 5, 5, 0, 0, 2 * Math.PI);
            ctx.fill();
            for(let i in upgrades) {
                if(upgrades[i].connect) {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "rgb(194, 194, 194)"
                    ctx.beginPath(); 
                    ctx.moveTo(upgrades[i].x, upgrades[i].y); 
                    ctx.lineTo(upgrades[upgrades[i].connect].x, upgrades[upgrades[i].connect].y); 
                    ctx.stroke();
                } else {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "rgb(194, 194, 194)"
                    ctx.beginPath(); 
                    ctx.moveTo(upgrades[i].x, upgrades[i].y); 
                    ctx.lineTo(0, 0); 
                    ctx.stroke();
                }
            }
            for(let i in upgrades) {
                var colorScheme = [];
                switch(upgrades[i].colorScheme) {
                    case "jack":
                        colorScheme = ["rgb(224, 152, 224)", "rgb(219, 92, 219)", "rgb(219, 9, 215)"]
                    break;
                    case "mana":
                        colorScheme = ["rgb(161, 151, 222)", "rgb(94, 100, 217)", "rgb(11, 14, 217)"]
                    break;
                    case "health":
                        colorScheme = ["rgb(158, 222, 151)", "rgb(94, 217, 102)", "rgb(0, 179, 18)"]
                    break;
                    case "mobility":
                        colorScheme = ["rgb(222, 198, 151)", "rgb(217, 172, 94)", "rgb(230, 153, 0)"]
                    break;
                }
                button(canvas.width/2 + upgrades[i].x, canvas.height/2 + upgrades[i].y, 20, 20, upgrades[i].func, {hoverColor: colorScheme[1], color: colorScheme[0], txtColor: "rgb(0, 0, 0)", txtSize: 15, txt: upgrades[i].spCost, args: undefined, yOffset: 5, upgrade: i, upgradeCol: colorScheme[2], upgradeButton: true, desc: upgrades[i].desc, name: i})
            }
            for(var i in upgrades) {
                let opts = upgrades[i]
                if(dist(mouseX, mouseY, canvas.width/2 + opts.x - cam.x, canvas.height/2 + opts.y - cam.y) < 20) {
                    ctx.fillStyle = "rgb(150, 150, 150)"
                    ctx.fillRect(mouseX + cam.x - canvas.width/2, mouseY + cam.y - canvas.height/2, 150, 100)
                    ctx.fillStyle = "rgb(0, 0, 0)";
                    ctx.font = "20px Arial"
                    ctx.textAlign = "left"
                    ctx.fillText(i, mouseX + cam.x - canvas.width/2 + 2, mouseY + cam.y + 18 - canvas.height/2)
                    ctx.font = "15px Arial"
                    wrappedText(upgrades[i].desc, mouseX + cam.x - canvas.width/2 + 2, mouseY + cam.y + 38 - canvas.height/2, 140, 20)
                }
            }
            ctx.translate(cam.x, cam.y)
            button(10, 10, 40, 25, function() {
                scene = "game"
                ctx.translate(cam.x, cam.y)
                ctx.translate(-player.x, -player.y)
            }, {hoverColor: "rgb(100, 100, 100)", color: "rgb(150, 150, 150)", txtColor: "rgb(0, 0, 0)", txtSize: 15, txt: "Exit", args: undefined, yOffset: 5})
            ctx.fillStyle = "rgb(150, 150, 150)"
            ctx.fillRect(-canvas.width/2, canvas.height/2 - 45, 150, 45)
            ctx.textAlign = "left"
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillText("Level: " + player.lvl, -canvas.width/2 + 5, canvas.height/2 - 27.5);
            ctx.fillText("Skill Points: " + player.sp, -canvas.width/2 + 5, canvas.height/2 - 7.5);
            ctx.translate(-cam.x, -cam.y)
        break;
    }
    frameCount+=1;
    clicked = false;
}, 20);
    </script>
</body>

</html>
